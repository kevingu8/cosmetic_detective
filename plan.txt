Week 0 (½–1 week): foundations & decisions

Objectives

Lock the stack: Expo/React Native (iOS+Android), Firebase (Auth/Firestore/Storage/Cloud Functions), Next.js reviewer console.

Create three environments: dev, staging, prod.

Define the V1 data model (users, tickets, results, messages) and ticket lifecycle (submitted → in_review → resolved / need_more_info / rejected).

Tasks

Set up repos (mobile / web console / cloud) and CI builds.

Create Firebase projects & buckets; add app icons, bundle IDs, package names.

Draft Firestore indexes you’ll likely need (status, assignedReviewerId, createdAt).

Write “Definition of Done” for MVP (see bottom).

Deliverables

System diagram, data dictionary, lifecycle state machine.

Issue tracker with epics: Mobile, Backend, Reviewer Console, Ops.

Week 1: mobile UX with mocked data (prove the flow)

Objectives

You can navigate: Login → New Ticket → Upload screen (dummy) → Ticket List → Ticket Detail (status timeline).

Validate 维鉴-style UX before wiring real backend.

Tasks

Design low-fi wireframes for 6 screens: Onboarding/Login, Home, New Ticket, Upload, Ticket List, Ticket Detail.

Implement screens with local mocks: hardcoded tickets, fake statuses, placeholder images.

Add form validation, loading/empty/error states.

Instrument basic analytics events (screen views, tap flows).

Acceptance

You can “submit” a ticket (mocked), see it in the list, open detail, and watch a simulated status change.

Week 2: real backend for core objects (auth, storage, CRUD)

Objectives

Real sign-in, real ticket creation, real image uploads (compressed), secure reads/writes.

Tasks

Enable Auth providers (pick 1–2 for MVP: Email/Apple/Google).

Connect New Ticket to Storage uploads and Firestore writes.

Implement minimal security rules: users only see their data; reviewers/admins gated by role.

Add realtime listeners for user’s ticket list and detail.

Write a tiny Cloud Function to stamp audit fields and normalize status on create.

Acceptance

From device/simulator, you sign in, create a ticket with 1–5 images, and see it in your list; data is present in Firestore/Storage; rules block cross-user access.

Week 3: reviewer console (web) + assignment flow

Objectives

A single-operator console to process tickets end-to-end.

Tasks

Reviewer login with role claims.

Ticket queue with filters (unassigned, mine, status).

Claim/unclaim, open detail, zoom images, quick notes.

Verdict form (authentic / inauthentic / undetermined) with rationale.

Write result to results (or tickets/{id}/result) and flip ticket status to resolved.

Acceptance

You can submit a ticket from the app, claim it on the console, publish a verdict, and see the result reflected on the phone.

Week 4: chat, notifications, and SLAs

Objectives

Two-way messaging for clarifications; push notifications for key events; basic SLA handling.

Tasks

Messages subcollection with realtime updates; simple chat UI on both sides.

Push notifications: save device tokens; send on assignment, message, verdict.

SLA helpers: compute slaAt on create; highlight overdue in console; auto-nudge function.

Acceptance

Reviewer sends a message; user receives a push and sees it in-app; user replies; reviewer is notified. Tickets overdue past SLA are visible.

Week 5: polish, compliance, and beta build

Objectives

Hardening for test distribution; store-compliant content; internal testers on both platforms.

Tasks

Error handling (network loss, large photos), retryable uploads, image size caps.

Empty states, localization stubs (EN/中文), accessibility pass on critical screens.

Privacy Policy + Terms (cover image rights, retention, takedowns).

App metadata drafts (screenshots, descriptions).

Build to TestFlight + Play internal testing tracks; invite 3–5 trusted testers.

Acceptance

Testers can install, submit, get a human verdict within your target turnaround, and report no P0 blockers.